// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Connect4$Game = require("./Connect4.bs.js");
var CS17SetupGame$Game = require("./CS17SetupGame.bs.js");

function AIPlayer(MyGame) {
  var nextMove = function (s) {
    var minimax = function (state, depth) {
      var match = Curry._1(MyGame[/* gameStatus */5], state);
      var match$1 = depth === 0;
      if (match$1) {
        return Curry._1(MyGame[/* estimateValue */8], state);
      } else if (typeof match === "number") {
        return 0.0;
      } else if (match.tag) {
        if (match[0]) {
          var _m = Number.POSITIVE_INFINITY;
          var _values = List.map((function (i) {
                  return minimax(Curry._2(MyGame[/* nextState */6], state, i), CS17SetupGame$Game.$neg(depth, 1));
                }), Curry._1(MyGame[/* legalMoves */4], state));
          while(true) {
            var values = _values;
            var m = _m;
            if (values) {
              var tl = values[1];
              var hd = values[0];
              _values = tl;
              if (m < hd) {
                continue ;
              } else {
                _m = hd;
                continue ;
              }
            } else {
              return m;
            }
          };
        } else {
          var _m$1 = Number.NEGATIVE_INFINITY;
          var _values$1 = List.map((function (i) {
                  return minimax(Curry._2(MyGame[/* nextState */6], state, i), CS17SetupGame$Game.$neg(depth, 1));
                }), Curry._1(MyGame[/* legalMoves */4], state));
          while(true) {
            var values$1 = _values$1;
            var m$1 = _m$1;
            if (values$1) {
              var tl$1 = values$1[1];
              var hd$1 = values$1[0];
              _values$1 = tl$1;
              if (m$1 > hd$1) {
                continue ;
              } else {
                _m$1 = hd$1;
                continue ;
              }
            } else {
              return m$1;
            }
          };
        }
      } else if (match[0]) {
        return Number.NEGATIVE_INFINITY;
      } else {
        return Number.POSITIVE_INFINITY;
      }
    };
    var nextStatePaths = List.map((function (i) {
            return /* tuple */[
                    Curry._2(MyGame[/* nextState */6], s, i),
                    i
                  ];
          }), Curry._1(MyGame[/* legalMoves */4], s));
    var nextValuePaths = function (_moves, _acc) {
      while(true) {
        var acc = _acc;
        var moves = _moves;
        if (moves) {
          var match = moves[0];
          var m = match[1];
          var s = match[0];
          if (Caml_obj.caml_equal(Curry._1(MyGame[/* gameStatus */5], s), /* Win */Block.__(0, [/* P1 */0]))) {
            return /* :: */[
                    /* tuple */[
                      Number.POSITIVE_INFINITY,
                      m
                    ],
                    /* [] */0
                  ];
          } else if (Caml_obj.caml_equal(Curry._1(MyGame[/* gameStatus */5], s), /* Win */Block.__(0, [/* P2 */1]))) {
            return /* :: */[
                    /* tuple */[
                      Number.NEGATIVE_INFINITY,
                      m
                    ],
                    /* [] */0
                  ];
          } else {
            _acc = /* :: */[
              /* tuple */[
                minimax(s, 4),
                m
              ],
              acc
            ];
            _moves = moves[1];
            continue ;
          }
        } else {
          return acc;
        }
      };
    };
    var match = Curry._1(MyGame[/* gameStatus */5], s);
    if (typeof match === "number") {
      return Pervasives.failwith("game is over, draw");
    } else if (match.tag) {
      if (match[0]) {
        var moves = nextValuePaths(nextStatePaths, /* [] */0);
        var _min = List.hd(moves);
        var _pairs = List.tl(moves);
        while(true) {
          var pairs = _pairs;
          var min = _min;
          if (pairs) {
            var tl = pairs[1];
            var match$1 = pairs[0];
            var hd = match$1[0];
            _pairs = tl;
            if (hd < min[0]) {
              _min = /* tuple */[
                hd,
                match$1[1]
              ];
              continue ;
            } else {
              continue ;
            }
          } else {
            Pervasives.string_of_float(min[0]);
            return min[1];
          }
        };
      } else {
        var moves$1 = nextValuePaths(nextStatePaths, /* [] */0);
        var _max = List.hd(moves$1);
        var _pairs$1 = List.tl(moves$1);
        while(true) {
          var pairs$1 = _pairs$1;
          var max = _max;
          if (pairs$1) {
            var tl$1 = pairs$1[1];
            var match$2 = pairs$1[0];
            var hd$1 = match$2[0];
            _pairs$1 = tl$1;
            if (hd$1 > max[0]) {
              _max = /* tuple */[
                hd$1,
                match$2[1]
              ];
              continue ;
            } else {
              continue ;
            }
          } else {
            Pervasives.string_of_float(max[0]);
            return max[1];
          }
        };
      }
    } else {
      return Pervasives.failwith("game is over, win");
    }
  };
  return /* module */[
          /* PlayerGame */MyGame,
          /* nextMove */nextMove
        ];
}

var MyGame_000 = Connect4$Game.Connect4[3];

var MyGame_001 = Connect4$Game.Connect4[6];

var MyGame_002 = Connect4$Game.Connect4[7];

var MyGame_003 = Connect4$Game.Connect4[9];

var MyGame_004 = Connect4$Game.Connect4[10];

var MyGame_005 = Connect4$Game.Connect4[11];

var MyGame_006 = Connect4$Game.Connect4[15];

var MyGame_007 = Connect4$Game.Connect4[16];

var MyGame_008 = Connect4$Game.Connect4[17];

var MyGame = [
  MyGame_000,
  MyGame_001,
  MyGame_002,
  MyGame_003,
  MyGame_004,
  MyGame_005,
  MyGame_006,
  MyGame_007,
  MyGame_008
];

function nextMove(s) {
  var minimax = function (state, depth) {
    var match = Curry._1(MyGame_005, state);
    var match$1 = depth === 0;
    if (match$1) {
      return Curry._1(MyGame_008, state);
    } else if (typeof match === "number") {
      return 0.0;
    } else if (match.tag) {
      if (match[0]) {
        var _m = Number.POSITIVE_INFINITY;
        var _values = List.map((function (i) {
                return minimax(Curry._2(MyGame_006, state, i), CS17SetupGame$Game.$neg(depth, 1));
              }), Curry._1(MyGame_004, state));
        while(true) {
          var values = _values;
          var m = _m;
          if (values) {
            var tl = values[1];
            var hd = values[0];
            _values = tl;
            if (m < hd) {
              continue ;
            } else {
              _m = hd;
              continue ;
            }
          } else {
            return m;
          }
        };
      } else {
        var _m$1 = Number.NEGATIVE_INFINITY;
        var _values$1 = List.map((function (i) {
                return minimax(Curry._2(MyGame_006, state, i), CS17SetupGame$Game.$neg(depth, 1));
              }), Curry._1(MyGame_004, state));
        while(true) {
          var values$1 = _values$1;
          var m$1 = _m$1;
          if (values$1) {
            var tl$1 = values$1[1];
            var hd$1 = values$1[0];
            _values$1 = tl$1;
            if (m$1 > hd$1) {
              continue ;
            } else {
              _m$1 = hd$1;
              continue ;
            }
          } else {
            return m$1;
          }
        };
      }
    } else if (match[0]) {
      return Number.NEGATIVE_INFINITY;
    } else {
      return Number.POSITIVE_INFINITY;
    }
  };
  var nextStatePaths = List.map((function (i) {
          return /* tuple */[
                  Curry._2(MyGame_006, s, i),
                  i
                ];
        }), Curry._1(MyGame_004, s));
  var nextValuePaths = function (_moves, _acc) {
    while(true) {
      var acc = _acc;
      var moves = _moves;
      if (moves) {
        var match = moves[0];
        var m = match[1];
        var s = match[0];
        if (Caml_obj.caml_equal(Curry._1(MyGame_005, s), /* Win */Block.__(0, [/* P1 */0]))) {
          return /* :: */[
                  /* tuple */[
                    Number.POSITIVE_INFINITY,
                    m
                  ],
                  /* [] */0
                ];
        } else if (Caml_obj.caml_equal(Curry._1(MyGame_005, s), /* Win */Block.__(0, [/* P2 */1]))) {
          return /* :: */[
                  /* tuple */[
                    Number.NEGATIVE_INFINITY,
                    m
                  ],
                  /* [] */0
                ];
        } else {
          _acc = /* :: */[
            /* tuple */[
              minimax(s, 4),
              m
            ],
            acc
          ];
          _moves = moves[1];
          continue ;
        }
      } else {
        return acc;
      }
    };
  };
  var match = Curry._1(MyGame_005, s);
  if (typeof match === "number") {
    return Pervasives.failwith("game is over, draw");
  } else if (match.tag) {
    if (match[0]) {
      var moves = nextValuePaths(nextStatePaths, /* [] */0);
      var _min = List.hd(moves);
      var _pairs = List.tl(moves);
      while(true) {
        var pairs = _pairs;
        var min = _min;
        if (pairs) {
          var tl = pairs[1];
          var match$1 = pairs[0];
          var hd = match$1[0];
          _pairs = tl;
          if (hd < min[0]) {
            _min = /* tuple */[
              hd,
              match$1[1]
            ];
            continue ;
          } else {
            continue ;
          }
        } else {
          Pervasives.string_of_float(min[0]);
          return min[1];
        }
      };
    } else {
      var moves$1 = nextValuePaths(nextStatePaths, /* [] */0);
      var _max = List.hd(moves$1);
      var _pairs$1 = List.tl(moves$1);
      while(true) {
        var pairs$1 = _pairs$1;
        var max = _max;
        if (pairs$1) {
          var tl$1 = pairs$1[1];
          var match$2 = pairs$1[0];
          var hd$1 = match$2[0];
          _pairs$1 = tl$1;
          if (hd$1 > max[0]) {
            _max = /* tuple */[
              hd$1,
              match$2[1]
            ];
            continue ;
          } else {
            continue ;
          }
        } else {
          Pervasives.string_of_float(max[0]);
          return max[1];
        }
      };
    }
  } else {
    return Pervasives.failwith("game is over, win");
  }
}

var TestAIPlayer = /* module */[
  /* PlayerGame */MyGame,
  /* nextMove */nextMove
];

var TestGame = 0;

exports.AIPlayer = AIPlayer;
exports.TestGame = TestGame;
exports.TestAIPlayer = TestAIPlayer;
/* Connect4-Game Not a pure module */

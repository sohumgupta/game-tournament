// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Connect4$Game = require("./Connect4.bs.js");
var CS17SetupGame$Game = require("./CS17SetupGame.bs.js");

function AIPlayer(MyGame) {
  var nextMove = function (s) {
    var minHelper = function (fltLst) {
      var _input = fltLst;
      var _locMin = List.hd(fltLst);
      while(true) {
        var locMin = _locMin;
        var input = _input;
        if (input) {
          var tl = input[1];
          var hd = input[0];
          if (hd < locMin) {
            _locMin = hd;
            _input = tl;
            continue ;
          } else {
            _input = tl;
            continue ;
          }
        } else {
          return locMin;
        }
      };
    };
    var maxHelper = function (fltLst) {
      var _input = fltLst;
      var _locMax = List.hd(fltLst);
      while(true) {
        var locMax = _locMax;
        var input = _input;
        if (input) {
          var tl = input[1];
          var hd = input[0];
          if (hd > locMax) {
            _locMax = hd;
            _input = tl;
            continue ;
          } else {
            _input = tl;
            continue ;
          }
        } else {
          return locMax;
        }
      };
    };
    var miniMaxP1 = function (stat, depth) {
      var exit = 0;
      switch (depth) {
        case 1 : 
        case 3 : 
            exit = 2;
            break;
        case 2 : 
        case 4 : 
            exit = 1;
            break;
        case 5 : 
            return Curry._1(MyGame[/* estimateValue */8], stat);
        default:
          return Pervasives.failwith("miniMaxP1 outside range of estimation");
      }
      switch (exit) {
        case 1 : 
            return maxHelper(List.map((function (x) {
                              return miniMaxP1(x, CS17SetupGame$Game.$plus(depth, 1));
                            }), List.map((function (x) {
                                  return Curry._2(MyGame[/* nextState */6], stat, x);
                                }), Curry._1(MyGame[/* legalMoves */4], stat))));
        case 2 : 
            return minHelper(List.map((function (x) {
                              return miniMaxP1(x, CS17SetupGame$Game.$plus(depth, 1));
                            }), List.map((function (x) {
                                  return Curry._2(MyGame[/* nextState */6], stat, x);
                                }), Curry._1(MyGame[/* legalMoves */4], stat))));
        
      }
    };
    var miniMaxP2 = function (stat, depth) {
      var exit = 0;
      switch (depth) {
        case 1 : 
        case 3 : 
            exit = 2;
            break;
        case 2 : 
        case 4 : 
            exit = 1;
            break;
        case 5 : 
            return Curry._1(MyGame[/* estimateValue */8], stat);
        default:
          return Pervasives.failwith("miniMaxP2 outside range of estimation");
      }
      switch (exit) {
        case 1 : 
            return minHelper(List.map((function (x) {
                              return miniMaxP2(x, CS17SetupGame$Game.$plus(depth, 1));
                            }), List.map((function (x) {
                                  return Curry._2(MyGame[/* nextState */6], stat, x);
                                }), Curry._1(MyGame[/* legalMoves */4], stat))));
        case 2 : 
            return maxHelper(List.map((function (x) {
                              return miniMaxP2(x, CS17SetupGame$Game.$plus(depth, 1));
                            }), List.map((function (x) {
                                  return Curry._2(MyGame[/* nextState */6], stat, x);
                                }), Curry._1(MyGame[/* legalMoves */4], stat))));
        
      }
    };
    var possibleMoves = Curry._1(MyGame[/* legalMoves */4], s);
    var match = Curry._1(MyGame[/* gameStatus */5], s);
    if (typeof match === "number" || !match.tag) {
      return Pervasives.failwith("nextMove, game ended, no moves to make");
    } else if (match[0]) {
      var fmPair = List.map((function (x) {
              return /* tuple */[
                      miniMaxP2(Curry._2(MyGame[/* nextState */6], s, x), 1),
                      x
                    ];
            }), possibleMoves);
      var _input = fmPair;
      var _acc = List.hd(fmPair);
      while(true) {
        var acc = _acc;
        var input = _input;
        if (input) {
          var tl = input[1];
          var match$1 = input[0];
          var num = match$1[0];
          if (num < acc[0]) {
            _acc = /* tuple */[
              num,
              match$1[1]
            ];
            _input = tl;
            continue ;
          } else {
            _input = tl;
            continue ;
          }
        } else {
          return acc[1];
        }
      };
    } else {
      var fmPair$1 = List.map((function (x) {
              return /* tuple */[
                      miniMaxP1(Curry._2(MyGame[/* nextState */6], s, x), 1),
                      x
                    ];
            }), possibleMoves);
      var _input$1 = fmPair$1;
      var _acc$1 = List.hd(fmPair$1);
      while(true) {
        var acc$1 = _acc$1;
        var input$1 = _input$1;
        if (input$1) {
          var tl$1 = input$1[1];
          var match$2 = input$1[0];
          var num$1 = match$2[0];
          if (num$1 > acc$1[0]) {
            _acc$1 = /* tuple */[
              num$1,
              match$2[1]
            ];
            _input$1 = tl$1;
            continue ;
          } else {
            _input$1 = tl$1;
            continue ;
          }
        } else {
          return acc$1[1];
        }
      };
    }
  };
  return /* module */[
          /* PlayerGame */MyGame,
          /* nextMove */nextMove
        ];
}

var MyGame_000 = Connect4$Game.Connect4[5];

var MyGame_001 = Connect4$Game.Connect4[6];

var MyGame_002 = Connect4$Game.Connect4[7];

var MyGame_003 = Connect4$Game.Connect4[9];

var MyGame_004 = Connect4$Game.Connect4[10];

var MyGame_005 = Connect4$Game.Connect4[11];

var MyGame_006 = Connect4$Game.Connect4[15];

var MyGame_007 = Connect4$Game.Connect4[8];

var MyGame_008 = Connect4$Game.Connect4[16];

var MyGame = [
  MyGame_000,
  MyGame_001,
  MyGame_002,
  MyGame_003,
  MyGame_004,
  MyGame_005,
  MyGame_006,
  MyGame_007,
  MyGame_008
];

function nextMove(s) {
  var minHelper = function (fltLst) {
    var _input = fltLst;
    var _locMin = List.hd(fltLst);
    while(true) {
      var locMin = _locMin;
      var input = _input;
      if (input) {
        var tl = input[1];
        var hd = input[0];
        if (hd < locMin) {
          _locMin = hd;
          _input = tl;
          continue ;
        } else {
          _input = tl;
          continue ;
        }
      } else {
        return locMin;
      }
    };
  };
  var maxHelper = function (fltLst) {
    var _input = fltLst;
    var _locMax = List.hd(fltLst);
    while(true) {
      var locMax = _locMax;
      var input = _input;
      if (input) {
        var tl = input[1];
        var hd = input[0];
        if (hd > locMax) {
          _locMax = hd;
          _input = tl;
          continue ;
        } else {
          _input = tl;
          continue ;
        }
      } else {
        return locMax;
      }
    };
  };
  var miniMaxP1 = function (stat, depth) {
    var exit = 0;
    switch (depth) {
      case 1 : 
      case 3 : 
          exit = 2;
          break;
      case 2 : 
      case 4 : 
          exit = 1;
          break;
      case 5 : 
          return Curry._1(MyGame_008, stat);
      default:
        return Pervasives.failwith("miniMaxP1 outside range of estimation");
    }
    switch (exit) {
      case 1 : 
          return maxHelper(List.map((function (x) {
                            return miniMaxP1(x, CS17SetupGame$Game.$plus(depth, 1));
                          }), List.map((function (x) {
                                return Curry._2(MyGame_006, stat, x);
                              }), Curry._1(MyGame_004, stat))));
      case 2 : 
          return minHelper(List.map((function (x) {
                            return miniMaxP1(x, CS17SetupGame$Game.$plus(depth, 1));
                          }), List.map((function (x) {
                                return Curry._2(MyGame_006, stat, x);
                              }), Curry._1(MyGame_004, stat))));
      
    }
  };
  var miniMaxP2 = function (stat, depth) {
    var exit = 0;
    switch (depth) {
      case 1 : 
      case 3 : 
          exit = 2;
          break;
      case 2 : 
      case 4 : 
          exit = 1;
          break;
      case 5 : 
          return Curry._1(MyGame_008, stat);
      default:
        return Pervasives.failwith("miniMaxP2 outside range of estimation");
    }
    switch (exit) {
      case 1 : 
          return minHelper(List.map((function (x) {
                            return miniMaxP2(x, CS17SetupGame$Game.$plus(depth, 1));
                          }), List.map((function (x) {
                                return Curry._2(MyGame_006, stat, x);
                              }), Curry._1(MyGame_004, stat))));
      case 2 : 
          return maxHelper(List.map((function (x) {
                            return miniMaxP2(x, CS17SetupGame$Game.$plus(depth, 1));
                          }), List.map((function (x) {
                                return Curry._2(MyGame_006, stat, x);
                              }), Curry._1(MyGame_004, stat))));
      
    }
  };
  var possibleMoves = Curry._1(MyGame_004, s);
  var match = Curry._1(MyGame_005, s);
  if (typeof match === "number" || !match.tag) {
    return Pervasives.failwith("nextMove, game ended, no moves to make");
  } else if (match[0]) {
    var fmPair = List.map((function (x) {
            return /* tuple */[
                    miniMaxP2(Curry._2(MyGame_006, s, x), 1),
                    x
                  ];
          }), possibleMoves);
    var _input = fmPair;
    var _acc = List.hd(fmPair);
    while(true) {
      var acc = _acc;
      var input = _input;
      if (input) {
        var tl = input[1];
        var match$1 = input[0];
        var num = match$1[0];
        if (num < acc[0]) {
          _acc = /* tuple */[
            num,
            match$1[1]
          ];
          _input = tl;
          continue ;
        } else {
          _input = tl;
          continue ;
        }
      } else {
        return acc[1];
      }
    };
  } else {
    var fmPair$1 = List.map((function (x) {
            return /* tuple */[
                    miniMaxP1(Curry._2(MyGame_006, s, x), 1),
                    x
                  ];
          }), possibleMoves);
    var _input$1 = fmPair$1;
    var _acc$1 = List.hd(fmPair$1);
    while(true) {
      var acc$1 = _acc$1;
      var input$1 = _input$1;
      if (input$1) {
        var tl$1 = input$1[1];
        var match$2 = input$1[0];
        var num$1 = match$2[0];
        if (num$1 > acc$1[0]) {
          _acc$1 = /* tuple */[
            num$1,
            match$2[1]
          ];
          _input$1 = tl$1;
          continue ;
        } else {
          _input$1 = tl$1;
          continue ;
        }
      } else {
        return acc$1[1];
      }
    };
  }
}

var TestAIPlayer = /* module */[
  /* PlayerGame */MyGame,
  /* nextMove */nextMove
];

var TestGame = 0;

exports.AIPlayer = AIPlayer;
exports.TestGame = TestGame;
exports.TestAIPlayer = TestAIPlayer;
/* Connect4-Game Not a pure module */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Connect4$Game1 = require("./Connect4.bs.js");
var CS17SetupGame$Game1 = require("./CS17SetupGame.bs.js");

function AIPlayer(MyGame) {
  var nextMove = function (s) {
    var alphaBeta = function (current, depth, isMax, alpha, beta) {
      if (depth === 0 || Curry._1(MyGame.legalMoves, current) === /* [] */0) {
        return Curry._1(MyGame.estimateValue, current);
      } else {
        var nextList = List.map((function (x) {
                return Curry._2(MyGame.nextState, current, x);
              }), Curry._1(MyGame.legalMoves, current));
        if (isMax) {
          var _childLstA = nextList;
          var depthA = CS17SetupGame$Game1.$neg(depth, 1);
          var isMaxA = !isMax;
          var _alpha = alpha;
          var beta$1 = beta;
          var _bestA = -1.0 * Number.MAX_VALUE;
          while(true) {
            var bestA = _bestA;
            var alpha$1 = _alpha;
            var childLstA = _childLstA;
            if (childLstA) {
              var u1 = alphaBeta(childLstA[0], depthA, isMaxA, alpha$1, beta$1);
              var v1 = u1 > bestA ? u1 : bestA;
              var a = alpha$1 > v1 ? alpha$1 : v1;
              if (a >= beta$1) {
                return v1;
              } else {
                _bestA = v1;
                _alpha = a;
                _childLstA = childLstA[1];
                continue ;
              }
            } else {
              return bestA;
            }
          };
        } else {
          var _childLstB = nextList;
          var depthB = CS17SetupGame$Game1.$neg(depth, 1);
          var isMaxB = !isMax;
          var alpha$2 = alpha;
          var _beta = beta;
          var _bestB = Number.MAX_VALUE;
          while(true) {
            var bestB = _bestB;
            var beta$2 = _beta;
            var childLstB = _childLstB;
            if (childLstB) {
              var u2 = alphaBeta(childLstB[0], depthB, isMaxB, alpha$2, beta$2);
              var v2 = u2 < bestB ? u2 : bestB;
              var b = beta$2 < v2 ? beta$2 : v2;
              if (alpha$2 >= b) {
                return v2;
              } else {
                _bestB = v2;
                _beta = b;
                _childLstB = childLstB[1];
                continue ;
              }
            } else {
              return bestB;
            }
          };
        }
      }
    };
    var maxMoveIndex = function (vList) {
      var maxHelper = function (lst) {
        if (lst) {
          var tl = lst[1];
          var x = lst[0];
          if (tl) {
            var match = maxHelper(tl);
            var temp = match[1];
            if (x > temp) {
              return /* tuple */[
                      0,
                      x
                    ];
            } else {
              return /* tuple */[
                      CS17SetupGame$Game1.$plus(match[0], 1),
                      temp
                    ];
            }
          } else {
            return /* tuple */[
                    0,
                    x
                  ];
          }
        } else {
          return Pervasives.failwith("No legal moves available");
        }
      };
      return maxHelper(vList)[0];
    };
    var minMoveIndex = function (vList) {
      var minHelper = function (lst) {
        if (lst) {
          var tl = lst[1];
          var x = lst[0];
          if (tl) {
            var match = minHelper(tl);
            var temp = match[1];
            if (x < temp) {
              return /* tuple */[
                      0,
                      x
                    ];
            } else {
              return /* tuple */[
                      CS17SetupGame$Game1.$plus(match[0], 1),
                      temp
                    ];
            }
          } else {
            return /* tuple */[
                    0,
                    x
                  ];
          }
        } else {
          return Pervasives.failwith("No legal moves available");
        }
      };
      return minHelper(vList)[0];
    };
    var match = Curry._1(MyGame.gameStatus, s);
    if (typeof match === "number") {
      return Pervasives.failwith("Game has ended in a Draw");
    } else if (match.tag) {
      if (match[0]) {
        var possibleMoves2 = Curry._1(MyGame.legalMoves, s);
        var nextLst2 = List.map((function (x) {
                return Curry._2(MyGame.nextState, s, x);
              }), possibleMoves2);
        var valList2 = List.map((function (x) {
                return alphaBeta(x, 6, true, -1.0 * Number.MAX_VALUE, Number.MAX_VALUE);
              }), nextLst2);
        return List.nth(possibleMoves2, minMoveIndex(valList2));
      } else {
        var possibleMoves1 = Curry._1(MyGame.legalMoves, s);
        var nextLst1 = List.map((function (x) {
                return Curry._2(MyGame.nextState, s, x);
              }), possibleMoves1);
        var valList1 = List.map((function (x) {
                return alphaBeta(x, 6, false, -1.0 * Number.MAX_VALUE, Number.MAX_VALUE);
              }), nextLst1);
        return List.nth(possibleMoves1, maxMoveIndex(valList1));
      }
    } else {
      return Pervasives.failwith("Game has ended");
    }
  };
  return {
          PlayerGame: MyGame,
          nextMove: nextMove
        };
}

var MyGame_stringOfPlayer = Connect4$Game1.Connect4.stringOfPlayer;

var MyGame_stringOfState = Connect4$Game1.Connect4.stringOfState;

var MyGame_stringOfMove = Connect4$Game1.Connect4.stringOfMove;

var MyGame_initialState = Connect4$Game1.Connect4.initialState;

var MyGame_legalMoves = Connect4$Game1.Connect4.legalMoves;

var MyGame_gameStatus = Connect4$Game1.Connect4.gameStatus;

var MyGame_nextState = Connect4$Game1.Connect4.nextState;

var MyGame_moveOfString = Connect4$Game1.Connect4.moveOfString;

var MyGame_estimateValue = Connect4$Game1.Connect4.estimateValue;

var MyGame = {
  stringOfPlayer: MyGame_stringOfPlayer,
  stringOfState: MyGame_stringOfState,
  stringOfMove: MyGame_stringOfMove,
  initialState: MyGame_initialState,
  legalMoves: MyGame_legalMoves,
  gameStatus: MyGame_gameStatus,
  nextState: MyGame_nextState,
  moveOfString: MyGame_moveOfString,
  estimateValue: MyGame_estimateValue
};

function nextMove(s) {
  var alphaBeta = function (current, depth, isMax, alpha, beta) {
    if (depth === 0 || Curry._1(MyGame_legalMoves, current) === /* [] */0) {
      return Curry._1(MyGame_estimateValue, current);
    } else {
      var nextList = List.map((function (x) {
              return Curry._2(MyGame_nextState, current, x);
            }), Curry._1(MyGame_legalMoves, current));
      if (isMax) {
        var _childLstA = nextList;
        var depthA = CS17SetupGame$Game1.$neg(depth, 1);
        var isMaxA = !isMax;
        var _alpha = alpha;
        var beta$1 = beta;
        var _bestA = -1.0 * Number.MAX_VALUE;
        while(true) {
          var bestA = _bestA;
          var alpha$1 = _alpha;
          var childLstA = _childLstA;
          if (childLstA) {
            var u1 = alphaBeta(childLstA[0], depthA, isMaxA, alpha$1, beta$1);
            var v1 = u1 > bestA ? u1 : bestA;
            var a = alpha$1 > v1 ? alpha$1 : v1;
            if (a >= beta$1) {
              return v1;
            } else {
              _bestA = v1;
              _alpha = a;
              _childLstA = childLstA[1];
              continue ;
            }
          } else {
            return bestA;
          }
        };
      } else {
        var _childLstB = nextList;
        var depthB = CS17SetupGame$Game1.$neg(depth, 1);
        var isMaxB = !isMax;
        var alpha$2 = alpha;
        var _beta = beta;
        var _bestB = Number.MAX_VALUE;
        while(true) {
          var bestB = _bestB;
          var beta$2 = _beta;
          var childLstB = _childLstB;
          if (childLstB) {
            var u2 = alphaBeta(childLstB[0], depthB, isMaxB, alpha$2, beta$2);
            var v2 = u2 < bestB ? u2 : bestB;
            var b = beta$2 < v2 ? beta$2 : v2;
            if (alpha$2 >= b) {
              return v2;
            } else {
              _bestB = v2;
              _beta = b;
              _childLstB = childLstB[1];
              continue ;
            }
          } else {
            return bestB;
          }
        };
      }
    }
  };
  var maxMoveIndex = function (vList) {
    var maxHelper = function (lst) {
      if (lst) {
        var tl = lst[1];
        var x = lst[0];
        if (tl) {
          var match = maxHelper(tl);
          var temp = match[1];
          if (x > temp) {
            return /* tuple */[
                    0,
                    x
                  ];
          } else {
            return /* tuple */[
                    CS17SetupGame$Game1.$plus(match[0], 1),
                    temp
                  ];
          }
        } else {
          return /* tuple */[
                  0,
                  x
                ];
        }
      } else {
        return Pervasives.failwith("No legal moves available");
      }
    };
    return maxHelper(vList)[0];
  };
  var minMoveIndex = function (vList) {
    var minHelper = function (lst) {
      if (lst) {
        var tl = lst[1];
        var x = lst[0];
        if (tl) {
          var match = minHelper(tl);
          var temp = match[1];
          if (x < temp) {
            return /* tuple */[
                    0,
                    x
                  ];
          } else {
            return /* tuple */[
                    CS17SetupGame$Game1.$plus(match[0], 1),
                    temp
                  ];
          }
        } else {
          return /* tuple */[
                  0,
                  x
                ];
        }
      } else {
        return Pervasives.failwith("No legal moves available");
      }
    };
    return minHelper(vList)[0];
  };
  var match = Curry._1(MyGame_gameStatus, s);
  if (typeof match === "number") {
    return Pervasives.failwith("Game has ended in a Draw");
  } else if (match.tag) {
    if (match[0]) {
      var possibleMoves2 = Curry._1(MyGame_legalMoves, s);
      var nextLst2 = List.map((function (x) {
              return Curry._2(MyGame_nextState, s, x);
            }), possibleMoves2);
      var valList2 = List.map((function (x) {
              return alphaBeta(x, 6, true, -1.0 * Number.MAX_VALUE, Number.MAX_VALUE);
            }), nextLst2);
      return List.nth(possibleMoves2, minMoveIndex(valList2));
    } else {
      var possibleMoves1 = Curry._1(MyGame_legalMoves, s);
      var nextLst1 = List.map((function (x) {
              return Curry._2(MyGame_nextState, s, x);
            }), possibleMoves1);
      var valList1 = List.map((function (x) {
              return alphaBeta(x, 6, false, -1.0 * Number.MAX_VALUE, Number.MAX_VALUE);
            }), nextLst1);
      return List.nth(possibleMoves1, maxMoveIndex(valList1));
    }
  } else {
    return Pervasives.failwith("Game has ended");
  }
}

var TestAIPlayer = {
  PlayerGame: MyGame,
  nextMove: nextMove
};

var TestGame = 0;

exports.AIPlayer = AIPlayer;
exports.TestGame = TestGame;
exports.TestAIPlayer = TestAIPlayer;
/* Connect4-Game1 Not a pure module */

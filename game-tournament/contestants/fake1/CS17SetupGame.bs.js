// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var Overflow = Caml_exceptions.create("CS17SetupGame-Game1.Overflow");

function $plus(a, b) {
  var c = a + b | 0;
  if ((a ^ b | a ^ Pervasives.lnot(c)) < 0) {
    return c;
  } else {
    throw Overflow;
  }
}

function $neg(a, b) {
  var c = a - b | 0;
  if ((a ^ Pervasives.lnot(b) | b ^ c) < 0) {
    return c;
  } else {
    throw Overflow;
  }
}

function $star(a, b) {
  var c = Caml_int32.imul(a, b);
  if (Caml_int64.eq(Caml_int64.of_int32(c), Caml_int64.mul(Caml_int64.of_int32(a), Caml_int64.of_int32(b)))) {
    return c;
  } else {
    throw Overflow;
  }
}

function $slash(a, b) {
  if (a === Pervasives.min_int && b === -1) {
    throw Overflow;
  }
  return Caml_int32.div(a, b);
}

function $tilde$neg(x) {
  if (x !== Pervasives.min_int) {
    return -x | 0;
  } else {
    throw Overflow;
  }
}

function printGreen(s) {
  return Pervasives.print_string("\x1b[32m" + (s + "\x1b[0m\n"));
}

function printRed(s) {
  return Pervasives.print_string("\x1b[31m" + (s + "\x1b[0m\n"));
}

function checkExpect(actual, expected, message) {
  if (Caml_obj.caml_equal(actual, expected)) {
    printGreen("ce_Success: " + message);
    return /* Test_Passed */0;
  } else {
    printRed("ce_Fail: " + message);
    printRed("expected output: ");
    console.log(expected);
    printRed("actual output: ");
    console.log(actual);
    return /* Test_Failed */[
            /* Actual_Result */Block.__(0, [actual]),
            /* Expected_Result */Block.__(1, [expected])
          ];
  }
}

function checkError(input, expect) {
  try {
    return /* Test_Failed */[
            /* Actual_Result */Block.__(0, [Curry._1(input, /* () */0)]),
            /* Expected_Error */Block.__(3, [expect])
          ];
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      var err = exn[1];
      if (err === expect) {
        printGreen("ce_Success ");
        return /* Test_Passed */0;
      } else {
        printRed("err_Fail ");
        return /* Test_Failed */[
                /* Actual_Error */Block.__(2, [err]),
                /* Expected_Error */Block.__(3, [expect])
              ];
      }
    } else {
      throw exn;
    }
  }
}

exports.Overflow = Overflow;
exports.$plus = $plus;
exports.$neg = $neg;
exports.$star = $star;
exports.$slash = $slash;
exports.$tilde$neg = $tilde$neg;
exports.printGreen = printGreen;
exports.printRed = printRed;
exports.checkExpect = checkExpect;
exports.checkError = checkError;
/* No side effect */
